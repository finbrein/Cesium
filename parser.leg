%{
#include "ast.h"
#include "symbol.h"
#include "exception.h"

#define YYSTYPE ast_t *

#define YY_INPUT(buf, result, max_size, core)         \
{                                                     \
  int yyc = fgetc(stdin);                             \
  if (yyc == EOF) longjmp(exc, 2);                    \
  result = (EOF == yyc) ? 0 : (*(buf)= yyc, 1);       \
}
%}

start         = Spacing r:TopStatement { root = r; } 
                 | ( !EOL .)* EOL { root = NULL; printf("Syntax error\n"); }
TopStatement  = Symtab ';' { print_sym_tab(); }
                 | VarStmt ';'
                 | Statement
Statement     = IfStmt
                 | Expression ';'
                 | ';'
VarStmt       = Var r:VarAssign 
                 ( Comma s:VarAssign 
              {
                 s->next = r;
                 r = s;
              }
                 )*
              {
                 r = ast_reverse(r);
                 $$ = ast_unary(r, AST_VARASSIGN);
              }
IfStmt        = ( If LParen e:Expression RParen s1:Statement Spacing Else s2:Statement
              { 
                 $$ = ast_stmt3(e, s1, s2, AST_IFELSE); 
              } )
              | ( If LParen e:Expression RParen s1:Statement Spacing ';'
              { 
                 $$ = ast_stmt2(e, s1, AST_IF); 
              } )
              | ( If LParen e:Expression RParen s1:Statement
              { 
                 $$ = ast_stmt2(e, s1, AST_IF); 
              } )

VarAssign     = Assignment | Identifier
Assignment    = r:Identifier Equals s:AssignExp
              {
                 r->next = s;
                 $$ = ast_unary(r, AST_ASSIGNMENT);
              }
Expression    = AssignExp
AssignExp     = Assignment
                 | ( r:Identifier o:PlusEQ s:AssignExp { $$ = ast_binary(r, s, o); } )
                 | ( r:Identifier o:MinusEQ s:AssignExp { $$ = ast_binary(r, s, o); } )
                 | ( r:Identifier o:TimesEQ s:AssignExp { $$ = ast_binary(r, s, o); } )
                 | ( r:Identifier o:DivEQ s:AssignExp { $$ = ast_binary(r, s, o); } )
                 | ( r:Identifier o:ModEQ s:AssignExp { $$ = ast_binary(r, s, o); } )
                 | ( r:Identifier o:AndEQ s:AssignExp { $$ = ast_binary(r, s, o); } )
                 | ( r:Identifier o:OrEQ s:AssignExp { $$ = ast_binary(r, s, o); } )
                 | ( r:Identifier o:XorEQ s:AssignExp { $$ = ast_binary(r, s, o); } )
                 | ( r:Identifier o:RshEQ s:AssignExp { $$ = ast_binary(r, s, o); } )
                 | ( r:Identifier o:LshEQ s:AssignExp { $$ = ast_binary(r, s, o); } )
                 | Infix100
Infix100      = ( r:Infix90 ( o:LogOr 
                  s:Infix90 { r = ast_binary(r, s, o); } )* ) { $$ = r; }
Infix90       = ( r:Infix80 ( o:LogAnd 
                  s:Infix80 { r = ast_binary(r, s, o); } )* ) { $$ = r; }
Infix80       = ( r:Infix70 ( o:BitOr 
                  s:Infix70 { r = ast_binary(r, s, o); } )* ) { $$ = r; }
Infix70       = ( r:Infix60 ( o:BitXor 
                  s:Infix60 { r = ast_binary(r, s, o); } )* ) { $$ = r; }
Infix60       = ( r:Infix50 ( o:BitAnd 
                  s:Infix50 { r = ast_binary(r, s, o); } )* ) { $$ = r; }
Infix50       = ( r:Infix40 ( ( o:EQ | o:NE ) 
                  s:Infix40 { r = ast_binary(r, s, o); } )* ) { $$ = r; }
Infix40       = ( r:Infix30 ( ( o:LE | o:GE | o:LT | o:GT ) 
                  s:Infix30 { r = ast_binary(r, s, o); } )* ) { $$ = r; }
Infix30       = ( r:Infix20 ( ( o:Lsh | o:Rsh) 
                  s:Infix20 { r = ast_binary(r, s, o); }  )* ) { $$ = r; }
Infix20       = ( r:Infix10 ( ( o:Plus | o:Minus ) 
                  s:Infix10 { r = ast_binary(r, s, o); } )* ) { $$ = r; }
Infix10       = ( r:UnaryExp ( ( o:Times | o:Div | o:Mod ) 
                  s: UnaryExp { r = ast_binary(r, s, o); } )* ) { $$ = r; }
UnaryExp      = ( Incr s:Identifier { $$ = ast_unary(s, AST_PRE_INC); } ) 
                 | ( Decr s:Identifier { $$ = ast_unary(s, AST_PRE_DEC); } ) 
                 | ( Plus UnaryExp ) 
                 | ( Minus s:UnaryExp { $$ = ast_unary(s, AST_UNMINUS); } ) 
                 | ( LogNot s:UnaryExp { $$ = ast_unary(s, AST_LOGNOT); } ) 
                 | ( BitNot s:UnaryExp { $$ = ast_unary(s, AST_BITNOT); } ) 
                 | PostfixExp 
PostfixExp    = ( r:Identifier Incr ) { $$ = ast_unary(r, AST_POST_INC); }
                 | ( r:Identifier Decr ) { $$ = ast_unary(r, AST_POST_DEC); }
                 | Primary 
Primary       = ( Boolean | Identifier | Double | IntConst | String 
                 | ( LParen Expression RParen ) )

Var           = 'var' Spacing
If            = 'if' Spacing
Else          = 'else' Spacing
Symtab        = 'symtab' Spacing
Comma         = ',' Spacing
Identifier    = < IdentStart IdentCont* > Spacing
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(sym, AST_IDENT);
              }
IdentStart    = [a-zA-Z_]
IdentCont     = IdentStart | [0-9]
IntConst      = < Integer 'u'? ( 'b' | 'w' | 'd' | 'q' )? > Spacing
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(sym, AST_INT);
              }
Integer       = < ( [1-9] [0-9]* | '0' ) >
String        = < Quotes ( SlashQuotes | ( !Quotes . ) )* Quotes > Spacing
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(sym, AST_STRING);
              }
Double        = < Integer '.' [0-9]+ ( ( 'e' | 'E' ) '-'? Integer )? ( 'f' | 'd' )? > Spacing
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(sym, AST_DOUBLE);
              }
Boolean       = True | False
Spacing       = ( Space | Comment )*
Space         = ' ' | '\t' | EOL
Comment       = Comment1 | Comment2
Comment1      = '//' ( !EOL . )* EOL 
Comment2      = '/*' ( !'*/' . )* '*/'
LParen        = '(' Spacing
RParen        = ')' Spacing
Incr          = '++' Spacing
Decr          = '--' Spacing
Plus          = '+' Spacing { $$ = op_plus; }
Minus         = '-' Spacing { $$ = op_minus; }
LogNot        = '!' Spacing 
LogAnd        = '&&' Spacing { $$ = op_logand; }
LogOr         = '||' Spacing { $$ = op_logor; }
BitNot        = '~' Spacing
BitAnd        = '&' Spacing { $$ = op_bitand; }
BitXor        = '^|' Spacing { $$ = op_bitxor; }
BitOr         = '|' Spacing { $$ = op_bitor; }
Times         = '*' Spacing { $$ = op_times; }
Div           = '/' Spacing { $$ = op_div; }
Mod           = '%' Spacing { $$ = op_mod; }
Lsh           = '<<' Spacing { $$ = op_lsh; }
Rsh           = '>>' Spacing  { $$ = op_rsh; }
LT            = '<' Spacing { $$ = op_lt; } 
GT            = '>' Spacing { $$ = op_gt; }
LE            = '<=' Spacing { $$ = op_le; }
GE            = '>=' Spacing { $$ = op_ge; }
EQ            = '==' Spacing { $$ = op_eq; }
NE            = '!=' Spacing { $$ = op_ne; }
Equals        = '=' Spacing
PlusEQ        = '+=' Spacing { $$ = op_pluseq; }
MinusEQ       = '-=' Spacing { $$ = op_minuseq; }
TimesEQ       = '*=' Spacing { $$ = op_timeseq; }
DivEQ         = '/=' Spacing { $$ = op_diveq; }
ModEQ         = '%=' Spacing { $$ = op_modeq; }
AndEQ         = '&=' Spacing { $$ = op_andeq; }
OrEQ          = '|=' Spacing { $$ = op_oreq; }
XorEQ         = '^|=' Spacing { $$ = op_xoreq; }
RshEQ         = '>>=' Spacing { $$ = op_rsheq; }
LshEQ         = '<<=' Spacing { $$ = op_lsheq; }
True          = < 'true' > Spacing 
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(sym, AST_BOOL);
              }
False         = < 'false' > Spacing
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(sym, AST_BOOL);
              }
Quotes        = '"'
SlashQuotes   = '\\\"'
EOL           = '\r\n' | '\n' | '\r'
